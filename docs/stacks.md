# Stacks in C

**Stacks are reserved areas of memory used to keep track of program's internal operations, including functions,
return addresses, passed parameters, etc... A stack adds or removes data in a *Last in First Out(LIFO)* manner.**


The stack start right from the very start of C program's execution.
Stacks have a very important role in C program, that said, it's not surprising to say that more than %50 of bugs in C code
can be directly related to the stack issues, and the other half can be indirectly related to stack issues.

As it's said stacks are exist even before the execution of the program and that's what a typical C program would do:
1. Clear [BSS](https://en.wikipedia.org/wiki/.bss) regions to 0.
2. Init [data segment](https://en.wikipedia.org/wiki/Data_segment) with values from [ROM](https://en.wikipedia.org/wiki/Read-only_memory).
3. Set ip the [stack pointer](https://www.techtarget.com/whatis/definition/stack-pointer).
4. Jump to [C's first function](https://en.cppreference.com/w/c/language/main_function).

In the above steps, the most important part is the stack pointer. Whenever we're writing a C program the assembly code
generated by the compiler is looks like a lot of stack operations especially where function calls/returns are happening.

**The main purposes of stacks in C program:**
* Storing function's local variable.
* Passing parameters.
* Passing the return address to a function call.
* Temporary storage (variables that don't need to be allocated).
* Saving processor registers across function calls and returns.

**Function stack frames in C**
The way in which C compilers generate change from a processor to processor, intel x86 is different from ARM 32.
Processor manufacturers document properly *function calling conventions* to be followed by compilers for that processor.

Let's understand the *anatomy of Intel x86* processor.

*Some Notes:*
1. Stack grows downwards, from higher address to lower addresses.
2. To put data into the stack we use ***push*** operation and the address `(SP)` will decrement, 
for example if the current stack pointer is at 0x8 then it would be at 0x4.
3. To remove data from the stack we use ***pop*** operation which works otherwise of the push operation,
if the stack pointer is at 0x4 it would then be at 0x8 and data form 0x8 is returned/popped later on.
4. The size of data moved data pushed/popped during stack operations depends on the processor's word length. in Intel x86
the length of a word is 4 byte (32-bits).
```
+------------------------+
|         DATA           | 0xD  The origin of the strack
+------------------------+
|     Return to fun1     | 0xC
+------------------------+
|         DATA           | 0xB
+------------------------+
|    Return to fun2      | 0xA
+------------------------+
|         DATA           | 0x9          
+------------------------+ 
|    Return to fun3      | 0x8          
+------------------------+ <------------- Stack pointer
|            .           | 0x7             |
+------------------------+                 |
|            .           | 0x6             |
+------------------------+ <---------------|    free spaces
|            .           | 0x5             |
+------------------------+                 |
|            .           | 0x4             |
+------------------------+                 |
|            .           | 0x3
+------------------------+
|            .           | 0x2
+------------------------+
|            .           | 0x1
+------------------------+
|            .           | 0x0
+------------------------+
```

Each called functions have their own stack frames, let's analyze a stack frame on an x86 arch.

```c
int do(int param0, int param1)
{
	int var0;
	int var1;
	// Magic goes here...
	return var0;
}
```
And here is how it would look like inside a stack frame.
***EBP*** is base pointer register which indicates the origin of the current stack frame. Most of other locations
are accessed using offsets to EBP register.

In C, each function during execution, will have a current stack frame starting at an address pointed by ESP register.

```
    +------------------------------+
    |   Callee's saved registers   |
    |        EBX, ESI, EDI         |
    +------------------------------+
    |       Temporary storage      |
    +------------------------------+
    |          Local var1          | EBP - 8
    +------------------------------+
    |          Local var0          | EBP - 4
    +------------------------------+
EBP |         Caller's EBP         | EBP + 0
    +------------------------------+
    |    Caller's return address   | EBP + 4
    +------------------------------+
    |            Param0            | EBP + 8
    +------------------------------+
    |            Param1            | EBP + 12
    +------------------------------+
    |   Caller's saved registers   |
    |         EAX, ECX, EDX        |
    +------------------------------+
```